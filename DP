#include<bits/stdc++.h>
using namespace std;
// Max sum of non-adjacent elements: Recursion 
int solve(int index, vector<int> &arr) {
    // Base Cond
    if(index < 0) return 0 ;
    if(index == 0) return arr[0] ;
    
    // Pick
    int pick = arr[index] + solve(index-2, arr) ;
    
    // Not Pick
    int notPick = solve(index-1, arr) ;
    
    // Return Max sum of non-adj elements
    return max(pick, notPick) ;
}

int main() {
    vector<int> arr = {2,1,4,9} ;
    cout << solve(arr.size()-1, arr) ;
}

Output: 11

#include<bits/stdc++.h>
using namespace std;
// Max sum of non-adjacent elements: Recursion + Memoization
int solve(int index, vector<int> &arr, vector<int> &dp) {
    // Base Cond
    if(index < 0) return 0 ;
    if(index == 0) return arr[0] ;
    
    // Pre visited: return stored value
    if(dp[index] != -1) return dp[index] ;
    
    // Pick
    int pick = arr[index] + solve(index-2, arr, dp) ;
    
    // Not Pick
    int notPick = solve(index-1, arr, dp) ;
    
    // Return Max sum of non-adj elements
    return dp[index] =  max(pick, notPick) ;
}

int main() {
    vector<int> arr = {2,1,4,9} ;
    vector<int> dp(arr.size(),-1) ;
    cout << solve(arr.size()-1, arr, dp) ;
}
Output: 11

#include<bits/stdc++.h>
using namespace std;
// Max sum of non-adjacent elements: DP Tabulation
int solve(int index, vector<int> &arr, vector<int> &dp) {
    // Base Cond
    if(index < 0) return 0 ;
    if(index == 0) return arr[0] ;
    
    // Pre visited: return stored value
    if(dp[index] != -1) return dp[index] ;
    
    // Pick
    int pick = arr[index] + solve(index-2, arr, dp) ;
    
    // Not Pick
    int notPick = solve(index-1, arr, dp) ;
    
    // Return Max sum of non-adj elements
    return dp[index] =  max(pick, notPick) ;
}

int main() {
    vector<int> arr = {2,1,4,9} ;
    int n = arr.size() ;
    
    vector<int> dp(n,-1) ;
    // Base Cond
    dp[0] = arr[0] ; 
    
    for(int ind = 1 ; ind < n ; ind++) {
        int pick ;
        if(ind > 1 ) pick = arr[ind] + dp[ind-2] ;
        int notPick = dp[ind-1] ;
        dp[ind] =  max(pick, notPick) ;
    }
    
    cout << dp[n-1] ;
}

// Space Optimized
int main() {
    vector<int> arr = {2,1,4,9} ;
    int n = arr.size() ;
    
    int prev2 = 0 , prev ; 
    // Base Cond
    prev = arr[0] ; 
    
    for(int ind = 1 ; ind < n ; ind++) {
        int pick = arr[ind] ;
        if(ind > 1 ) pick += prev2 ;
        int notPick = prev ;
        
        int curr =  max(pick, notPick) ;
        
        prev2 = prev ;
        prev = curr ;
    }
    
    cout << prev ;
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Max sum of non-adjacent elements in Circular fashion
#include<bits/stdc++.h>
using namespace std;

int solve(int ind, vector<int> &arr) {
    
    if(ind == 0) return arr[0] ;
    if(ind < 0) return 0 ;
    
    int pick = arr[ind] + solve(ind - 2, arr) ;
    int notPick = solve(ind-1, arr) ;
    
    return max(pick, notPick) ;
}

int main() {
    
    vector<int> arr = {2,3,2,5} ;
    int n = arr.size() ;
    
    vector<int> num1, num2 ;
    for(int i = 0 ; i < n ; i++) {
        if(i != n-1) num1.push_back(arr[i]) ;
        if(i != 0) num2.push_back(arr[i]) ;
     }
  
    
    int max1 =  solve(n-1,num1) ;
    int max2 = solve(n-1,num2) ;
    
    cout << "Max Sum a robber can rob: " << max(max1,max2) ;
}

Output: Max Sum a robber can rob: 8

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include<bits/stdc++.h>
using namespace std ;

// Grid unique paths from (0,0) to (m,n) using Recursion

int solve(int m, int n) {
    
    if(m == 0 && n == 0) return 1 ;
    if(n < 0 || m < 0) return 0 ; 
    
    int up = solve(m-1,n) ;
    int left = solve(m,n-1) ;
    
    return up + left ; 
}

int main() {
    int m = 3 , n = 2 ;
    
    cout << "Grid Unique paths: "<< solve(m-1,n-1) << " Paths" ;
}

Output: Grid Unique paths: 3 Paths

#include<bits/stdc++.h>
using namespace std ;
// Grid unique paths from (0,0) to (m,n) using Recursion + Memoization
int solve(int m, int n, vector<vector<int>> &dp) {
    
    if(m == 0 && n == 0) return 1 ;
    if(n < 0 || m < 0) return 0 ; 
    
    if(dp[m][n] != -1) return dp[m][n] ; 
    
    int up = solve(m-1,n, dp) ;
    int left = solve(m,n-1, dp) ;
    
    return dp[m][n] = up + left ; 
}

int main() {
    int m = 3 , n = 2 ;
    
    vector<vector<int>> dp(m, vector<int>(n,-1)) ;
    cout << "Grid Unique paths: "<< solve(m-1,n-1, dp) << " Paths" ;
}

