#include<bits/stdc++.h>
using namespace std;
// Max sum of non-adjacent elements: Recursion 
int solve(int index, vector<int> &arr) {
    // Base Cond
    if(index < 0) return 0 ;
    if(index == 0) return arr[0] ;
    
    // Pick
    int pick = arr[index] + solve(index-2, arr) ;
    
    // Not Pick
    int notPick = solve(index-1, arr) ;
    
    // Return Max sum of non-adj elements
    return max(pick, notPick) ;
}

int main() {
    vector<int> arr = {2,1,4,9} ;
    cout << solve(arr.size()-1, arr) ;
}

Output: 11

#include<bits/stdc++.h>
using namespace std;
// Max sum of non-adjacent elements: Recursion + Memoization
int solve(int index, vector<int> &arr, vector<int> &dp) {
    // Base Cond
    if(index < 0) return 0 ;
    if(index == 0) return arr[0] ;
    
    // Pre visited: return stored value
    if(dp[index] != -1) return dp[index] ;
    
    // Pick
    int pick = arr[index] + solve(index-2, arr, dp) ;
    
    // Not Pick
    int notPick = solve(index-1, arr, dp) ;
    
    // Return Max sum of non-adj elements
    return dp[index] =  max(pick, notPick) ;
}

int main() {
    vector<int> arr = {2,1,4,9} ;
    vector<int> dp(arr.size(),-1) ;
    cout << solve(arr.size()-1, arr, dp) ;
}
Output: 11

#include<bits/stdc++.h>
using namespace std;
// Max sum of non-adjacent elements: DP Tabulation
int solve(int index, vector<int> &arr, vector<int> &dp) {
    // Base Cond
    if(index < 0) return 0 ;
    if(index == 0) return arr[0] ;
    
    // Pre visited: return stored value
    if(dp[index] != -1) return dp[index] ;
    
    // Pick
    int pick = arr[index] + solve(index-2, arr, dp) ;
    
    // Not Pick
    int notPick = solve(index-1, arr, dp) ;
    
    // Return Max sum of non-adj elements
    return dp[index] =  max(pick, notPick) ;
}

int main() {
    vector<int> arr = {2,1,4,9} ;
    int n = arr.size() ;
    
    vector<int> dp(n,-1) ;
    // Base Cond
    dp[0] = arr[0] ; 
    
    for(int ind = 1 ; ind < n ; ind++) {
        int pick ;
        if(ind > 1 ) pick = arr[ind] + dp[ind-2] ;
        int notPick = dp[ind-1] ;
        dp[ind] =  max(pick, notPick) ;
    }
    
    cout << dp[n-1] ;
}

// Space Optimized
int main() {
    vector<int> arr = {2,1,4,9} ;
    int n = arr.size() ;
    
    int prev2 = 0 , prev ; 
    // Base Cond
    prev = arr[0] ; 
    
    for(int ind = 1 ; ind < n ; ind++) {
        int pick = arr[ind] ;
        if(ind > 1 ) pick += prev2 ;
        int notPick = prev ;
        
        int curr =  max(pick, notPick) ;
        
        prev2 = prev ;
        prev = curr ;
    }
    
    cout << prev ;
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Max sum of non-adjacent elements in Circular fashion
#include<bits/stdc++.h>
using namespace std;

int solve(int ind, vector<int> &arr) {
    
    if(ind == 0) return arr[0] ;
    if(ind < 0) return 0 ;
    
    int pick = arr[ind] + solve(ind - 2, arr) ;
    int notPick = solve(ind-1, arr) ;
    
    return max(pick, notPick) ;
}

int main() {
    
    vector<int> arr = {2,3,2,5} ;
    int n = arr.size() ;
    
    vector<int> num1, num2 ;
    for(int i = 0 ; i < n ; i++) {
        if(i != n-1) num1.push_back(arr[i]) ;
        if(i != 0) num2.push_back(arr[i]) ;
     }
  
    
    int max1 =  solve(n-1,num1) ;
    int max2 = solve(n-1,num2) ;
    
    cout << "Max Sum a robber can rob: " << max(max1,max2) ;
}

Output: Max Sum a robber can rob: 8

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include<bits/stdc++.h>
using namespace std ;

// Grid unique paths from (0,0) to (m,n) using Recursion

int solve(int m, int n) {
    
    if(m == 0 && n == 0) return 1 ;
    if(n < 0 || m < 0) return 0 ; 
    
    int up = solve(m-1,n) ;
    int left = solve(m,n-1) ;
    
    return up + left ; 
}

int main() {
    int m = 3 , n = 2 ;
    
    cout << "Grid Unique paths: "<< solve(m-1,n-1) << " Paths" ;
}

Output: Grid Unique paths: 3 Paths

#include<bits/stdc++.h>
using namespace std ;
// Grid unique paths from (0,0) to (m,n) using Recursion + Memoization
int solve(int m, int n, vector<vector<int>> &dp) {
    
    if(m == 0 && n == 0) return 1 ;
    if(n < 0 || m < 0) return 0 ; 
    
    if(dp[m][n] != -1) return dp[m][n] ; 
    
    int up = solve(m-1,n, dp) ;
    int left = solve(m,n-1, dp) ;
    
    return dp[m][n] = up + left ; 
}

int main() {
    int m = 3 , n = 2 ;
    
    vector<vector<int>> dp(m, vector<int>(n,-1)) ;
    cout << "Grid Unique paths: "<< solve(m-1,n-1, dp) << " Paths" ;
}

Tabulation:

#include<bits/stdc++.h>
using namespace std ;

int solve(int m, int n, vector<vector<int>> &dp) {
    
    if(m == 0 && n == 0) return 1 ;
    if(n < 0 || m < 0) return 0 ; 
    
    if(dp[m][n] != -1) return dp[m][n] ; 
    
    int up = solve(m-1,n, dp) ;
    int left = solve(m,n-1, dp) ;
    
    return dp[m][n] = up + left ; 
}

int main() {
    int m = 3 , n = 2 ;
    
    vector<vector<int>> dp(m+1, vector<int>(n+1,0)) ;
    
    // 1st Approach for Base Cond
    // for(int i = 0 ; i < m ; i++) {
    //     for(int j = 0 ; j < n ; j++) {
    //         if(i == 0 && j == 0) {
    //             dp[0][0] = 1 ;
    //             continue ;
    //         }
            
    //         int up = 0 ; 
    //         if(i > 0) up += dp[i-1][j] ; 
            
    //         int left = 0 ;
    //         if(j > 0 ) left += dp[i][j-1] ;
            
    //         dp[i][j] = up + left ;
    //     }
    // }
    
    // cout << dp[m-1][n-1] ; 
    
    // 2nd Approach for Base Cond
    dp[0][0] = 1 ; 
    for(int j = 1 ; j < n ; j++) dp[0][j] = dp[0][j-1] ;
    
    for(int i = 1 ; i < m ; i++) dp[i][0] = dp[i-1][0] ;
    
    for(int i = 1 ; i < m ; i++) {
        for(int j = 1 ; j < n ; j++) {
            
            int up = dp[i-1][j] ;
            int left = dp[i][j-1] ;
            
            dp[i][j] = up + left ; 
        }
    }
    
    cout << dp[m-1][n-1] ; 
}

Space Optimized
#include<bits/stdc++.h>
using namespace std ;

int solve(int m, int n, vector<vector<int>> &dp) {
    
    if(m == 0 && n == 0) return 1 ;
    if(n < 0 || m < 0) return 0 ; 
    
    if(dp[m][n] != -1) return dp[m][n] ; 
    
    int up = solve(m-1,n, dp) ;
    int left = solve(m,n-1, dp) ;
    
    return dp[m][n] = up + left ; 
}

int main() {
    int m = 3 , n = 2 ;
    
    // vector<vector<int>> dp(m+1, vector<int>(n+1,0)) ;
    
    vector<int> prev(n,0), curr(n,0) ;
    
    // 1st Approach for Base Cond
    
    for(int i = 0 ; i < m ; i++) {
        for(int j = 0 ; j < n ; j++) {
            if(i == 0 && j == 0) {
                curr[0] = 1 ;
                continue ;
            }
            
            int up = 0 ; 
            if(i > 0) up += prev[j] ; 
            
            int left = 0 ;
            if(j > 0 ) left += curr[j-1] ;
            
            curr[j] = up + left ;
        }
        prev = curr ;
    }
    
    cout << prev[n-1] ; 
    
    // 2nd Approach for Base Cond
    // dp[0][0] = 1 ; 
    
    // vector<int> prev(n,0) ;
    // prev[0] = 0 ; 
    
    // for(int j = 1 ; j < n ; j++) prev[j] = 1 ; 
    
    // // for(int i = 1 ; i < m ; i++) dp[i][0] = dp[i-1][0] ;
    
    // for(int i = 1 ; i < m ; i++) {
        
    //     vector<int> curr(n,0) ; 
    //     curr[0] = 1 ;
        
    //     for(int j = 1 ; j < n ; j++) {
            
    //         int up = prev[j] ;
    //         int left = curr[j-1] ;
            
    //         curr[j] = up + left ;
    //     }
    //     prev = curr ; 
    // }
    
    // cout << prev[n-1] ; 
}
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
#include <bits/stdc++.h>
using namespace std ;
//Grid with obstacles using recursion

int solve(int m ,int n , vector<vector<int>> &maze) {
    
    if(m < 0 || n < 0 || maze[m][n] == -1) return 0 ;
    
    if(m == 0 && n ==0) return 1 ;
    
    int up = solve(m-1,n,maze) ;
    int left = solve(m,n-1,maze) ;
    return up + left ; 
}

int main() {
    
    vector<vector<int>> maze = { 
        {0,0,0},
        {0,-1,0},
        {0,0,0},
    } ;
    
    int m = maze.size() ;
    int n = maze[0].size() ;
    
    cout << solve(m-1,n-1, maze) ;
}

#include <bits/stdc++.h>
using namespace std ;
// Grid with obstacles using recursion + memoization
int solve(int m ,int n , vector<vector<int>> &maze, vector<vector<int>> &dp) {
    
    if(m < 0 || n < 0 || maze[m][n] == -1) return 0 ;
    
    if(m == 0 && n ==0) return 1 ;
    
    if(dp[m][n] != -1) return dp[m][n] ;
    
    int up = solve(m-1,n,maze, dp) ;
    int left = solve(m,n-1,maze, dp) ;
    return dp[m][n] =  up + left ; 
}

int main() {
    
    vector<vector<int>> maze = { 
        {0,0,0},
        {0,-1,0},
        {0,0,0},
    } ;
    
    int m = maze.size() ;
    int n = maze[0].size() ;
    
    vector<vector<int>> dp(m,vector<int>(n,-1)) ;
    
    cout << solve(m-1,n-1, maze, dp) ;
}

Tabulation : 
#include <bits/stdc++.h>
using namespace std ;

int solve(int m ,int n , vector<vector<int>> &maze, vector<vector<int>> &dp) {
    
    if(m < 0 || n < 0 || maze[m][n] == -1) return 0 ;
    
    if(m == 0 && n ==0) return 1 ;
    
    if(dp[m][n] != -1) return dp[m][n] ;
    
    int up = solve(m-1,n,maze, dp) ;
    int left = solve(m,n-1,maze, dp) ;
    return dp[m][n] =  up + left ; 
}

int main() {
    
    vector<vector<int>> maze = { 
        {0,0,0},
        {0,-1,0},
        {0,0,0},
    } ;
    
    int m = maze.size() ;
    int n = maze[0].size() ;
    
    vector<vector<int>> dp(m+1,vector<int>(n+1,0)) ;
    
    for(int i = 0 ; i < m ; i++) {
        for(int j = 0 ; j < n ; j++) {
            
            if(i == 0 && j == 0) {
                dp[0][0] = 1 ;
                continue ;
            }
            
            if(i > 0 && j > 0 && maze[i][j] == -1) {
                dp[i][j] = 0 ;
                continue ;
            }
            
            int up = 0 ;
            if(i > 0 ) up += dp[i-1][j] ; 
            
            int left = 0 ;
            if(j > 0) left += dp[i][j-1] ; 
            
            dp[i][j] = up + left ;
            
        }
    }
    cout << dp[m-1][n-1]; 
}

Space Optimized

#include <bits/stdc++.h>
using namespace std ;

int solve(int m ,int n , vector<vector<int>> &maze, vector<vector<int>> &dp) {
    
    if(m < 0 || n < 0 || maze[m][n] == -1) return 0 ;
    
    if(m == 0 && n ==0) return 1 ;
    
    if(dp[m][n] != -1) return dp[m][n] ;
    
    int up = solve(m-1,n,maze, dp) ;
    int left = solve(m,n-1,maze, dp) ;
    return dp[m][n] =  up + left ; 
}

int main() {
    
    vector<vector<int>> maze = { 
        {0,0,0},
        {0,-1,0},
        {0,0,0},
    } ;
    
    int m = maze.size() ;
    int n = maze[0].size() ;
    
    // vector<vector<int>> dp(m+1,vector<int>(n+1,0)) ;
    vector<int> prev(n,0) ;
    
    for(int i = 0 ; i < m ; i++) {
        vector<int> curr(n,0) ;
        for(int j = 0 ; j < n ; j++) {
            
            if(i == 0 && j == 0) {
                curr[0] = 1 ;
                continue ;
            }
            
            if(i > 0 && j > 0 && maze[i][j] == -1) {
                curr[j] = 0 ;
                continue ;
            }
            
            int up = 0 ;
            if(i > 0 ) up += prev[j] ; 
            
            int left = 0 ;
            if(j > 0) left += curr[j-1] ; 
            
            curr[j] = up + left ;
            
        }
        prev = curr ;
    }
    cout << prev[n-1]; 
}

##############################################################################################################################################################################################################
#include<bits/stdc++.h>
using namespace std ;
// Minimum Path sum in Grids using recursion
int solve(int m, int n, vector<vector<int>> &grid) {
    
    if(m < 0 || n < 0) return 1e9 ; ;
    
    if(m == 0 && n == 0) return grid[0][0] ; 
    
    int up = grid[m][n] + solve(m-1,n,grid) ;
    int left = grid[m][n] + solve(m,n-1,grid) ;
    
    return min(up,left) ;
}

int main() {
    
    vector<vector<int>> grid = {
        {5,9,6},
        {11,5,2},
    } ; 
    
    int m = grid.size() ;
    int n = grid[0].size() ;
    
    cout << solve(m-1,n-1,grid) ;
}

// Minimum Path sum in Grids using recursion + memoization

#include<bits/stdc++.h>
using namespace std ;

int solve(int m, int n, vector<vector<int>> &grid, vector<vector<int>> &dp) {
    
    if(m < 0 || n < 0) return 1e9 ; ;
    
    if(m == 0 && n == 0) return grid[0][0] ; 
    
    if(dp[m][n] != -1) return dp[m][n] ;
    
    int up = grid[m][n] + solve(m-1,n,grid,dp) ;
    int left = grid[m][n] + solve(m,n-1,grid, dp) ;
    
    return dp[m][n] =  min(up,left) ;
}

int main() {
    
    vector<vector<int>> grid = {
        {5,9,6},
        {11,5,2},
    } ; 
    
    int m = grid.size() ;
    int n = grid[0].size() ;
    
    vector<vector<int>> dp(m, vector<int>(n,-1)) ;
    cout << solve(m-1,n-1,grid, dp) ;
}

Space optimized

#include<bits/stdc++.h>
using namespace std ;

int solve(int m, int n, vector<vector<int>> &grid, vector<vector<int>> &dp) {
    
    if(m < 0 || n < 0) return 1e9 ; ;
    
    if(m == 0 && n == 0) return grid[0][0] ; 
    
    if(dp[m][n] != -1) return dp[m][n] ;
    
    int up = grid[m][n] + solve(m-1,n,grid,dp) ;
    int left = grid[m][n] + solve(m,n-1,grid, dp) ;
    
    return dp[m][n] =  min(up,left) ;
}

int main() {
    
    vector<vector<int>> grid = {
        {5,9,6},
        {11,5,2},
    } ; 
    
    int m = grid.size() ;
    int n = grid[0].size() ;
    
    vector<vector<int>> dp(m, vector<int>(n,0)) ;
    
    for(int i = 0 ; i < m ; i++ ) {
        for(int j = 0 ; j < n ; j++) {
            if(i == 0 && j == 0) {
                dp[0][0] = grid[0][0] ;
            }else {
                int up = grid[i][j] ;
                if(i > 0) {
                    up += dp[i-1][j] ;
                } else {
                    up += 1e9 ;
                }
                
                int left = grid[i][j] ;
                if(j > 0) {
                    left += dp[i][j-1] ;
                } else {
                    left += 1e9 ;
                }
                
                dp[i][j] = min(up,left) ;
            }
        }
    }
    
    cout << dp[m-1][n-1] ;
}
