#include<bits/stdc++.h>
using namespace std;
// Max sum of non-adjacent elements: Recursion 
int solve(int index, vector<int> &arr) {
    // Base Cond
    if(index < 0) return 0 ;
    if(index == 0) return arr[0] ;
    
    // Pick
    int pick = arr[index] + solve(index-2, arr) ;
    
    // Not Pick
    int notPick = solve(index-1, arr) ;
    
    // Return Max sum of non-adj elements
    return max(pick, notPick) ;
}

int main() {
    vector<int> arr = {2,1,4,9} ;
    cout << solve(arr.size()-1, arr) ;
}

Output: 11

#include<bits/stdc++.h>
using namespace std;
// Max sum of non-adjacent elements: Recursion + Memoization
int solve(int index, vector<int> &arr, vector<int> &dp) {
    // Base Cond
    if(index < 0) return 0 ;
    if(index == 0) return arr[0] ;
    
    // Pre visited: return stored value
    if(dp[index] != -1) return dp[index] ;
    
    // Pick
    int pick = arr[index] + solve(index-2, arr, dp) ;
    
    // Not Pick
    int notPick = solve(index-1, arr, dp) ;
    
    // Return Max sum of non-adj elements
    return dp[index] =  max(pick, notPick) ;
}

int main() {
    vector<int> arr = {2,1,4,9} ;
    vector<int> dp(arr.size(),-1) ;
    cout << solve(arr.size()-1, arr, dp) ;
}
Output: 11

#include<bits/stdc++.h>
using namespace std;
// Max sum of non-adjacent elements: DP Tabulation
int solve(int index, vector<int> &arr, vector<int> &dp) {
    // Base Cond
    if(index < 0) return 0 ;
    if(index == 0) return arr[0] ;
    
    // Pre visited: return stored value
    if(dp[index] != -1) return dp[index] ;
    
    // Pick
    int pick = arr[index] + solve(index-2, arr, dp) ;
    
    // Not Pick
    int notPick = solve(index-1, arr, dp) ;
    
    // Return Max sum of non-adj elements
    return dp[index] =  max(pick, notPick) ;
}

int main() {
    vector<int> arr = {2,1,4,9} ;
    int n = arr.size() ;
    
    vector<int> dp(n,-1) ;
    // Base Cond
    dp[0] = arr[0] ; 
    
    for(int ind = 1 ; ind < n ; ind++) {
        int pick ;
        if(ind > 1 ) pick = arr[ind] + dp[ind-2] ;
        int notPick = dp[ind-1] ;
        dp[ind] =  max(pick, notPick) ;
    }
    
    cout << dp[n-1] ;
}

// Space Optimized
int main() {
    vector<int> arr = {2,1,4,9} ;
    int n = arr.size() ;
    
    int prev2 = 0 , prev ; 
    // Base Cond
    prev = arr[0] ; 
    
    for(int ind = 1 ; ind < n ; ind++) {
        int pick = arr[ind] ;
        if(ind > 1 ) pick += prev2 ;
        int notPick = prev ;
        
        int curr =  max(pick, notPick) ;
        
        prev2 = prev ;
        prev = curr ;
    }
    
    cout << prev ;
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Max sum of non-adjacent elements in Circular fashion
#include<bits/stdc++.h>
using namespace std;

int solve(int ind, vector<int> &arr) {
    
    if(ind == 0) return arr[0] ;
    if(ind < 0) return 0 ;
    
    int pick = arr[ind] + solve(ind - 2, arr) ;
    int notPick = solve(ind-1, arr) ;
    
    return max(pick, notPick) ;
}

int main() {
    
    vector<int> arr = {2,3,2,5} ;
    int n = arr.size() ;
    
    vector<int> num1, num2 ;
    for(int i = 0 ; i < n ; i++) {
        if(i != n-1) num1.push_back(arr[i]) ;
        if(i != 0) num2.push_back(arr[i]) ;
     }
  
    
    int max1 =  solve(n-1,num1) ;
    int max2 = solve(n-1,num2) ;
    
    cout << "Max Sum a robber can rob: " << max(max1,max2) ;
}

Output: Max Sum a robber can rob: 8

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include<bits/stdc++.h>
using namespace std ;

// Grid unique paths from (0,0) to (m,n) using Recursion

int solve(int m, int n) {
    
    if(m == 0 && n == 0) return 1 ;
    if(n < 0 || m < 0) return 0 ; 
    
    int up = solve(m-1,n) ;
    int left = solve(m,n-1) ;
    
    return up + left ; 
}

int main() {
    int m = 3 , n = 2 ;
    
    cout << "Grid Unique paths: "<< solve(m-1,n-1) << " Paths" ;
}

Output: Grid Unique paths: 3 Paths

#include<bits/stdc++.h>
using namespace std ;
// Grid unique paths from (0,0) to (m,n) using Recursion + Memoization
int solve(int m, int n, vector<vector<int>> &dp) {
    
    if(m == 0 && n == 0) return 1 ;
    if(n < 0 || m < 0) return 0 ; 
    
    if(dp[m][n] != -1) return dp[m][n] ; 
    
    int up = solve(m-1,n, dp) ;
    int left = solve(m,n-1, dp) ;
    
    return dp[m][n] = up + left ; 
}

int main() {
    int m = 3 , n = 2 ;
    
    vector<vector<int>> dp(m, vector<int>(n,-1)) ;
    cout << "Grid Unique paths: "<< solve(m-1,n-1, dp) << " Paths" ;
}

Tabulation:

#include<bits/stdc++.h>
using namespace std ;

int solve(int m, int n, vector<vector<int>> &dp) {
    
    if(m == 0 && n == 0) return 1 ;
    if(n < 0 || m < 0) return 0 ; 
    
    if(dp[m][n] != -1) return dp[m][n] ; 
    
    int up = solve(m-1,n, dp) ;
    int left = solve(m,n-1, dp) ;
    
    return dp[m][n] = up + left ; 
}

int main() {
    int m = 3 , n = 2 ;
    
    vector<vector<int>> dp(m+1, vector<int>(n+1,0)) ;
    
    // 1st Approach for Base Cond
    // for(int i = 0 ; i < m ; i++) {
    //     for(int j = 0 ; j < n ; j++) {
    //         if(i == 0 && j == 0) {
    //             dp[0][0] = 1 ;
    //             continue ;
    //         }
            
    //         int up = 0 ; 
    //         if(i > 0) up += dp[i-1][j] ; 
            
    //         int left = 0 ;
    //         if(j > 0 ) left += dp[i][j-1] ;
            
    //         dp[i][j] = up + left ;
    //     }
    // }
    
    // cout << dp[m-1][n-1] ; 
    
    // 2nd Approach for Base Cond
    dp[0][0] = 1 ; 
    for(int j = 1 ; j < n ; j++) dp[0][j] = dp[0][j-1] ;
    
    for(int i = 1 ; i < m ; i++) dp[i][0] = dp[i-1][0] ;
    
    for(int i = 1 ; i < m ; i++) {
        for(int j = 1 ; j < n ; j++) {
            
            int up = dp[i-1][j] ;
            int left = dp[i][j-1] ;
            
            dp[i][j] = up + left ; 
        }
    }
    
    cout << dp[m-1][n-1] ; 
}

Space Optimized
#include<bits/stdc++.h>
using namespace std ;

int solve(int m, int n, vector<vector<int>> &dp) {
    
    if(m == 0 && n == 0) return 1 ;
    if(n < 0 || m < 0) return 0 ; 
    
    if(dp[m][n] != -1) return dp[m][n] ; 
    
    int up = solve(m-1,n, dp) ;
    int left = solve(m,n-1, dp) ;
    
    return dp[m][n] = up + left ; 
}

int main() {
    int m = 3 , n = 2 ;
    
    // vector<vector<int>> dp(m+1, vector<int>(n+1,0)) ;
    
    vector<int> prev(n,0), curr(n,0) ;
    
    // 1st Approach for Base Cond
    
    for(int i = 0 ; i < m ; i++) {
        for(int j = 0 ; j < n ; j++) {
            if(i == 0 && j == 0) {
                curr[0] = 1 ;
                continue ;
            }
            
            int up = 0 ; 
            if(i > 0) up += prev[j] ; 
            
            int left = 0 ;
            if(j > 0 ) left += curr[j-1] ;
            
            curr[j] = up + left ;
        }
        prev = curr ;
    }
    
    cout << prev[n-1] ; 
    
    // 2nd Approach for Base Cond
    // dp[0][0] = 1 ; 
    
    // vector<int> prev(n,0) ;
    // prev[0] = 0 ; 
    
    // for(int j = 1 ; j < n ; j++) prev[j] = 1 ; 
    
    // // for(int i = 1 ; i < m ; i++) dp[i][0] = dp[i-1][0] ;
    
    // for(int i = 1 ; i < m ; i++) {
        
    //     vector<int> curr(n,0) ; 
    //     curr[0] = 1 ;
        
    //     for(int j = 1 ; j < n ; j++) {
            
    //         int up = prev[j] ;
    //         int left = curr[j-1] ;
            
    //         curr[j] = up + left ;
    //     }
    //     prev = curr ; 
    // }
    
    // cout << prev[n-1] ; 
}
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
#include <bits/stdc++.h>
using namespace std ;
//Grid with obstacles using recursion

int solve(int m ,int n , vector<vector<int>> &maze) {
    
    if(m < 0 || n < 0 || maze[m][n] == -1) return 0 ;
    
    if(m == 0 && n ==0) return 1 ;
    
    int up = solve(m-1,n,maze) ;
    int left = solve(m,n-1,maze) ;
    return up + left ; 
}

int main() {
    
    vector<vector<int>> maze = { 
        {0,0,0},
        {0,-1,0},
        {0,0,0},
    } ;
    
    int m = maze.size() ;
    int n = maze[0].size() ;
    
    cout << solve(m-1,n-1, maze) ;
}

#include <bits/stdc++.h>
using namespace std ;
// Grid with obstacles using recursion + memoization
int solve(int m ,int n , vector<vector<int>> &maze, vector<vector<int>> &dp) {
    
    if(m < 0 || n < 0 || maze[m][n] == -1) return 0 ;
    
    if(m == 0 && n ==0) return 1 ;
    
    if(dp[m][n] != -1) return dp[m][n] ;
    
    int up = solve(m-1,n,maze, dp) ;
    int left = solve(m,n-1,maze, dp) ;
    return dp[m][n] =  up + left ; 
}

int main() {
    
    vector<vector<int>> maze = { 
        {0,0,0},
        {0,-1,0},
        {0,0,0},
    } ;
    
    int m = maze.size() ;
    int n = maze[0].size() ;
    
    vector<vector<int>> dp(m,vector<int>(n,-1)) ;
    
    cout << solve(m-1,n-1, maze, dp) ;
}

Tabulation : 
#include <bits/stdc++.h>
using namespace std ;

int solve(int m ,int n , vector<vector<int>> &maze, vector<vector<int>> &dp) {
    
    if(m < 0 || n < 0 || maze[m][n] == -1) return 0 ;
    
    if(m == 0 && n ==0) return 1 ;
    
    if(dp[m][n] != -1) return dp[m][n] ;
    
    int up = solve(m-1,n,maze, dp) ;
    int left = solve(m,n-1,maze, dp) ;
    return dp[m][n] =  up + left ; 
}

int main() {
    
    vector<vector<int>> maze = { 
        {0,0,0},
        {0,-1,0},
        {0,0,0},
    } ;
    
    int m = maze.size() ;
    int n = maze[0].size() ;
    
    vector<vector<int>> dp(m+1,vector<int>(n+1,0)) ;
    
    for(int i = 0 ; i < m ; i++) {
        for(int j = 0 ; j < n ; j++) {
            
            if(i == 0 && j == 0) {
                dp[0][0] = 1 ;
                continue ;
            }
            
            if(i > 0 && j > 0 && maze[i][j] == -1) {
                dp[i][j] = 0 ;
                continue ;
            }
            
            int up = 0 ;
            if(i > 0 ) up += dp[i-1][j] ; 
            
            int left = 0 ;
            if(j > 0) left += dp[i][j-1] ; 
            
            dp[i][j] = up + left ;
            
        }
    }
    cout << dp[m-1][n-1]; 
}

Space Optimized

#include <bits/stdc++.h>
using namespace std ;

int solve(int m ,int n , vector<vector<int>> &maze, vector<vector<int>> &dp) {
    
    if(m < 0 || n < 0 || maze[m][n] == -1) return 0 ;
    
    if(m == 0 && n ==0) return 1 ;
    
    if(dp[m][n] != -1) return dp[m][n] ;
    
    int up = solve(m-1,n,maze, dp) ;
    int left = solve(m,n-1,maze, dp) ;
    return dp[m][n] =  up + left ; 
}

int main() {
    
    vector<vector<int>> maze = { 
        {0,0,0},
        {0,-1,0},
        {0,0,0},
    } ;
    
    int m = maze.size() ;
    int n = maze[0].size() ;
    
    // vector<vector<int>> dp(m+1,vector<int>(n+1,0)) ;
    vector<int> prev(n,0) ;
    
    for(int i = 0 ; i < m ; i++) {
        vector<int> curr(n,0) ;
        for(int j = 0 ; j < n ; j++) {
            
            if(i == 0 && j == 0) {
                curr[0] = 1 ;
                continue ;
            }
            
            if(i > 0 && j > 0 && maze[i][j] == -1) {
                curr[j] = 0 ;
                continue ;
            }
            
            int up = 0 ;
            if(i > 0 ) up += prev[j] ; 
            
            int left = 0 ;
            if(j > 0) left += curr[j-1] ; 
            
            curr[j] = up + left ;
            
        }
        prev = curr ;
    }
    cout << prev[n-1]; 
}

##############################################################################################################################################################################################################
#include<bits/stdc++.h>
using namespace std ;
// Minimum Path sum in Grids using recursion
int solve(int m, int n, vector<vector<int>> &grid) {
    
    if(m < 0 || n < 0) return 1e9 ; ;
    
    if(m == 0 && n == 0) return grid[0][0] ; 
    
    int up = grid[m][n] + solve(m-1,n,grid) ;
    int left = grid[m][n] + solve(m,n-1,grid) ;
    
    return min(up,left) ;
}

int main() {
    
    vector<vector<int>> grid = {
        {5,9,6},
        {11,5,2},
    } ; 
    
    int m = grid.size() ;
    int n = grid[0].size() ;
    
    cout << solve(m-1,n-1,grid) ;
}

// Minimum Path sum in Grids using recursion + memoization

#include<bits/stdc++.h>
using namespace std ;

int solve(int m, int n, vector<vector<int>> &grid, vector<vector<int>> &dp) {
    
    if(m < 0 || n < 0) return 1e9 ; ;
    
    if(m == 0 && n == 0) return grid[0][0] ; 
    
    if(dp[m][n] != -1) return dp[m][n] ;
    
    int up = grid[m][n] + solve(m-1,n,grid,dp) ;
    int left = grid[m][n] + solve(m,n-1,grid, dp) ;
    
    return dp[m][n] =  min(up,left) ;
}

int main() {
    
    vector<vector<int>> grid = {
        {5,9,6},
        {11,5,2},
    } ; 
    
    int m = grid.size() ;
    int n = grid[0].size() ;
    
    vector<vector<int>> dp(m, vector<int>(n,-1)) ;
    cout << solve(m-1,n-1,grid, dp) ;
}

Space optimized

#include<bits/stdc++.h>
using namespace std ;

int solve(int m, int n, vector<vector<int>> &grid, vector<vector<int>> &dp) {
    
    if(m < 0 || n < 0) return 1e9 ; ;
    
    if(m == 0 && n == 0) return grid[0][0] ; 
    
    if(dp[m][n] != -1) return dp[m][n] ;
    
    int up = grid[m][n] + solve(m-1,n,grid,dp) ;
    int left = grid[m][n] + solve(m,n-1,grid, dp) ;
    
    return dp[m][n] =  min(up,left) ;
}

int main() {
    
    vector<vector<int>> grid = {
        {5,9,6},
        {11,5,2},
    } ; 
    
    int m = grid.size() ;
    int n = grid[0].size() ;
    
    vector<vector<int>> dp(m, vector<int>(n,0)) ;
    
    for(int i = 0 ; i < m ; i++ ) {
        for(int j = 0 ; j < n ; j++) {
            if(i == 0 && j == 0) {
                dp[0][0] = grid[0][0] ;
            }else {
                int up = grid[i][j] ;
                if(i > 0) {
                    up += dp[i-1][j] ;
                } else {
                    up += 1e9 ;
                }
                
                int left = grid[i][j] ;
                if(j > 0) {
                    left += dp[i][j-1] ;
                } else {
                    left += 1e9 ;
                }
                
                dp[i][j] = min(up,left) ;
            }
        }
    }
    
    cout << dp[m-1][n-1] ;
}

##############################################################################################################################################################################################################
Minimum Path sum in triangle one fixed path to variable end point
Recursion:
#include<bits/stdc++.h>
using namespace std ;

int solve(int n, int m, vector<vector<int>> &grid) {
    
    if(n == grid.size()-1) {
        return grid[n][m] ;
    }
    
    int down = grid[n][m] + solve(n+1,m, grid);
    int digonal = grid[n][m] + solve(n+1,m+1, grid) ;
    
    return min(down, digonal) ;
}

int main() {
    
    vector<vector<int>> grid = {
        {1},
        {2,3},
        {3,6,7},
        {8,9,6,10},
    } ;
    
    int n = grid.size() ;
    int m = grid[n-1].size() ;
    
    // cout << n ; 
    cout << solve(0,0,grid) ;
}

Recusion + Memoization
#include<bits/stdc++.h>
using namespace std ;

int solve(int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp) {
    
    if(n == grid.size()-1) {
        return grid[n][m] ;
    }
    
    if(dp[n][m] != -1) return dp[n][m] ;
    
    int down = grid[n][m] + solve(n+1,m, grid, dp);
    int digonal = grid[n][m] + solve(n+1,m+1, grid, dp) ;
    
    return dp[n][m] =  min(down, digonal) ;
}

int main() {
    
    vector<vector<int>> grid = {
        {1},
        {2,3},
        {3,6,7},
        {8,9,6,10},
    } ;
    
    int n = grid.size() ;
    int m = grid[n-1].size() ;
    
    vector<vector<int>> dp(n, vector<int>(m,-1)) ;
    
    // cout << n ; 
    cout << solve(0,0,grid, dp) ;
}

Tabulation : Bottom - Up 
#include<bits/stdc++.h>
using namespace std ;

int solve(int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp) {
    
    if(n == grid.size()-1) {
        return grid[n][m] ;
    }
    
    if(dp[n][m] != -1) return dp[n][m] ;
    
    int down = grid[n][m] + solve(n+1,m, grid, dp);
    int digonal = grid[n][m] + solve(n+1,m+1, grid, dp) ;
    
    return dp[n][m] =  min(down, digonal) ;
}

int main() {
    
    vector<vector<int>> grid = {
        {1},
        {2,3},
        {3,6,7},
        {8,9,6,10},
    } ;
    
    int n = grid.size() ;
    int m = grid[n-1].size() ;
    
    vector<vector<int>> dp(n, vector<int>(m,0)) ;
    
    for(int i = 0 ; i < m ; i++) {
        dp[n-1][i] = grid[n-1][i] ;
    }
    
    for(int i = n-2 ; i >= 0; i--) {
        for(int j = i ; j >= 0 ; j--) {
            
            int down = grid[i][j] + dp[i+1][j] ;
            int digonal = grid[i][j] + dp[i+1][j+1] ;
            
            dp[i][j] = min(down, digonal) ;
        }
    }

    cout << dp[0][0] ;
}

Space optimized

#include<bits/stdc++.h>
using namespace std ;

int solve(int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp) {
    
    if(n == grid.size()-1) {
        return grid[n][m] ;
    }
    
    if(dp[n][m] != -1) return dp[n][m] ;
    
    int down = grid[n][m] + solve(n+1,m, grid, dp);
    int digonal = grid[n][m] + solve(n+1,m+1, grid, dp) ;
    
    return dp[n][m] =  min(down, digonal) ;
}

int main() {
    
    vector<vector<int>> grid = {
        {1},
        {2,3},
        {3,6,7},
        {8,9,6,10},
    } ;
    
    int n = grid.size() ;
    int m = grid[n-1].size() ;
    
    // vector<vector<int>> dp(n, vector<int>(m,0)) ;
    
    vector<int> next(m,0) ;
    
    
    for(int i = 0 ; i < m ; i++) {
        next[i] = grid[n-1][i] ;
    }
    
    for(int i = n-2 ; i >= 0; i--) {
        vector<int> curr(m,0) ;
        
        for(int j = i ; j >= 0 ; j--) {
            
            int down = grid[i][j] + next[j] ;
            int digonal = grid[i][j] + next[j+1] ;
            
            curr[j] = min(down, digonal) ;
        }
        next = curr;
    }

    cout << next[0] ;
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Maximum Path sum from any point in first row to any point in last row
Recursion
#include<bits/stdc++.h>
using namespace std;

int solve(int n, int m, vector<vector<int>> &grid) {
    
    if(n == 0) {
        return grid[n][m] ;
    }
    
    if(m < 0 || m > grid[0].size()-1) return -1e9 ; 
    
    int up = grid[n][m] + solve(n-1,m, grid) ;
    int ld = grid[n][m] + solve(n-1,m-1, grid) ;
    int rd = grid[n][m] + solve(n-1,m+1,grid) ;
    
    return max(up, max(ld,rd)) ;
}

int main() {
    vector<vector<int>> grid = {
        {1,2,10,4},
        {100,3,2,1},
        {1,1,20,2},
        {1,2,2,1},
    } ;
    
    int n = grid.size() ;
    int m = grid[0].size() ;
    
    int maxi = -1e9 ;
    
    for(int i = 0 ; i < m ; i++) {
        maxi = max(maxi, solve(n-1,i,grid)) ;
    }
    
    cout << maxi ;
}

Recursion + Memoization

#include<bits/stdc++.h>
using namespace std;

int solve(int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp) {
    
    if(n == 0) {
        return grid[n][m] ;
    }
    
    if(m < 0 || m > grid[0].size()-1) return -1e9 ; 
    
    if(dp[n][m] != -1) return dp[n][m] ; 
    
    int up = grid[n][m] + solve(n-1,m, grid, dp) ;
    int ld = grid[n][m] + solve(n-1,m-1, grid, dp) ;
    int rd = grid[n][m] + solve(n-1,m+1,grid, dp) ;
    
    return dp[n][m] = max(up, max(ld,rd)) ;
}

int main() {
    vector<vector<int>> grid = {
        {1,2,10,4},
        {100,3,2,1},
        {1,1,20,2},
        {1,2,2,1},
    } ;
    
    int n = grid.size() ;
    int m = grid[0].size() ;
    vector<vector<int>> dp(n,vector<int>(m,-1)) ;
    
    int maxi = -1e9 ;
    
    for(int i = 0 ; i < m ; i++) {
        maxi = max(maxi, solve(n-1,i,grid, dp)) ;
    }
    
    cout << maxi ;
}

Tabulation: 

#include<bits/stdc++.h>
using namespace std;

int solve(int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp) {
    
    if(n == 0) {
        return grid[n][m] ;
    }
    
    if(m < 0 || m > grid[0].size()-1) return -1e9 ; 
    
    if(dp[n][m] != -1) return dp[n][m] ; 
    
    int up = grid[n][m] + solve(n-1,m, grid, dp) ;
    int ld = grid[n][m] + solve(n-1,m-1, grid, dp) ;
    int rd = grid[n][m] + solve(n-1,m+1,grid, dp) ;
    
    return dp[n][m] = max(up, max(ld,rd)) ;
}

int main() {
    vector<vector<int>> grid = {
        {1,2,10,4},
        {100,3,2,1},
        {1,1,20,2},
        {1,2,2,1},
    } ;
    
    int n = grid.size() ;
    int m = grid[0].size() ;
    vector<vector<int>> dp(n,vector<int>(m,0)) ;
    
    int maxi = -1e9 ;
    
    for(int i = 0 ; i < m ; i++) {
        dp[0][i] = grid[0][i] ;
    }
    
    for(int i = 1 ; i < n ; i++) {
        for(int j = 0 ; j < m ; j++) {
            
            int up = grid[i][j] + dp[i-1][j] ;
            
            int ld = grid[i][j] ;
            
            if(j > 0) ld += dp[i-1][j-1] ;
            else ld += -1e9 ;
            
            int rd = grid[i][j] ;
            if(j+1 < m ) rd += dp[i-1][j+1] ;
            else rd += -1e9 ;
            
            dp[i][j] = max(up, max(ld,rd)) ;
        }
    }
    
    
    for(int i = 0 ; i < m ; i++) {
        maxi = max(maxi, dp[n-1][i]) ;
    }
    
    cout << maxi ; 
}

Space Optimized

#include<bits/stdc++.h>
using namespace std;

int solve(int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp) {
    
    if(n == 0) {
        return grid[n][m] ;
    }
    
    if(m < 0 || m > grid[0].size()-1) return -1e9 ; 
    
    if(dp[n][m] != -1) return dp[n][m] ; 
    
    int up = grid[n][m] + solve(n-1,m, grid, dp) ;
    int ld = grid[n][m] + solve(n-1,m-1, grid, dp) ;
    int rd = grid[n][m] + solve(n-1,m+1,grid, dp) ;
    
    return dp[n][m] = max(up, max(ld,rd)) ;
}

int main() {
    vector<vector<int>> grid = {
        {1,2,10,4},
        {100,3,2,1},
        {1,1,20,2},
        {1,2,2,1},
    } ;
    
    int n = grid.size() ;
    int m = grid[0].size() ;
    // vector<vector<int>> dp(n,vector<int>(m,0)) ;
    vector<int> prev(m,0) ;
    
    int maxi = -1e9 ;
    
    for(int i = 0 ; i < m ; i++) {
        prev[i] = grid[0][i] ;
    }
    
    for(int i = 1 ; i < n ; i++) {
        vector<int> curr(m,0) ;
        for(int j = 0 ; j < m ; j++) {
            
            int up = grid[i][j] + prev[j] ;
            
            int ld = grid[i][j] ;
            
            if(j > 0) ld += prev[j-1] ;
            else ld += -1e9 ;
            
            int rd = grid[i][j] ;
            if(j+1 < m ) rd += prev[j+1] ;
            else rd += -1e9 ;
            
            curr[j] = max(up, max(ld,rd)) ;
        }
        prev = curr ;
    }
    
    
    for(int i = 0 ; i < m ; i++) {
        maxi = max(maxi, prev[i]) ;
    }
    
    cout << maxi ; 
}

*************************************************************************************************************************************************************************************************************
Ninja's Training with 'N' days with '3' Activities. Return max point by completing activity.
Recursion:
#include<bits/stdc++.h>
using namespace std;

int solve(int day, int last, vector<vector<int>> &grid) {
    
    if(day == 0) {
        int maxi = -1e9 ;
        
        for(int i = 0 ; i < 3 ; i++) {
            if(i != last) {
                maxi = max(maxi,grid[0][i]) ;
            }
        }
        return maxi ;
    }
    
    int maxi = -1e9 ;
    for(int i = 0 ; i < 3 ; i++) {
        if(i != last) {
            int activity = grid[day][i] + solve(day-1,i,grid) ;
            maxi = max(maxi,activity) ;
        }
    }
    return maxi ;
}

int main() {
    vector<vector<int>> grid = {
        {10,40,70},
        {20,50,80},
        {30,60,90},
    } ;
    
    int n = grid.size() ;
    
    cout << solve(n-1, 3, grid) ;
}

Recursion + Memoization:
#include<bits/stdc++.h>
using namespace std;

int solve(int day, int last, vector<vector<int>> &grid, vector<vector<int>> &dp) {
    
    if(dp[day][last] != -1) return dp[day][last] ;
    
    if(day == 0) {
        int maxi = -1e9 ;
        
        for(int i = 0 ; i < 3 ; i++) {
            if(i != last) {
                maxi = max(maxi,grid[0][i]) ;
            }
        }
        return dp[day][last] =  maxi ;
    }
    
    int maxi = -1e9 ;
    for(int i = 0 ; i < 3 ; i++) {
        if(i != last) {
            int activity = grid[day][i] + solve(day-1,i,grid,dp) ;
            maxi = max(maxi,activity) ;
        }
    }
    return dp[day][last] =  maxi ;
}

int main() {
    vector<vector<int>> grid = {
        {10,40,70},
        {20,50,80},
        {30,60,90},
    } ;
    
    int n = grid.size() ;
    vector<vector<int>> dp(n,vector<int>(4,-1)) ;
    
    cout << solve(n-1, 3, grid, dp) ;
}

Tabulation: 
#include<bits/stdc++.h>
using namespace std;

int solve(int day, int last, vector<vector<int>> &grid, vector<vector<int>> &dp) {
    
    if(dp[day][last] != -1) return dp[day][last] ;
    
    if(day == 0) {
        int maxi = -1e9 ;
        
        for(int i = 0 ; i < 3 ; i++) {
            if(i != last) {
                maxi = max(maxi,grid[0][i]) ;
            }
        }
        return dp[day][last] =  maxi ;
    }
    
    int maxi = -1e9 ;
    for(int i = 0 ; i < 3 ; i++) {
        if(i != last) {
            int activity = grid[day][i] + solve(day-1,i,grid,dp) ;
            maxi = max(maxi,activity) ;
        }
    }
    return dp[day][last] =  maxi ;
}

int main() {
    vector<vector<int>> grid = {
        {10,40,70},
        {20,50,80},
        {30,60,90},
    } ;
    
    int n = grid.size() ;
    vector<vector<int>> dp(n,vector<int>(4,0)) ;
    
    dp[0][0] = max(grid[0][1], grid[0][2]) ;
    dp[0][1] = max(grid[0][0], grid[0][2]) ;
    dp[0][2] = max(grid[0][0], grid[0][1]) ;
    dp[0][3] = max(grid[0][0], max(grid[0][1], grid[0][2])) ;
    
    for(int day = 1 ; day < n ; day++) {
        for(int last = 0 ; last < 4 ; last++) {
            
            int maxi = -1e9 ;
            for(int task = 0 ; task < 3 ; task++) {
                if(task != last) {
                    int activity = grid[day][task] + dp[day-1][task] ;
                    dp[day][last] = max(dp[day][last],activity) ;
                }
            }
        }
    }
    
    cout << dp[n-1][3] ;
    
}

Space Optimized:
#include<bits/stdc++.h>
using namespace std;

int solve(int day, int last, vector<vector<int>> &grid, vector<vector<int>> &dp) {
    
    if(dp[day][last] != -1) return dp[day][last] ;
    
    if(day == 0) {
        int maxi = -1e9 ;
        
        for(int i = 0 ; i < 3 ; i++) {
            if(i != last) {
                maxi = max(maxi,grid[0][i]) ;
            }
        }
        return dp[day][last] =  maxi ;
    }
    
    int maxi = -1e9 ;
    for(int i = 0 ; i < 3 ; i++) {
        if(i != last) {
            int activity = grid[day][i] + solve(day-1,i,grid,dp) ;
            maxi = max(maxi,activity) ;
        }
    }
    return dp[day][last] =  maxi ;
}

int main() {
    vector<vector<int>> grid = {
        {10,40,70},
        {20,50,80},
        {30,60,90},
    } ;
    
    int n = grid.size() ;
    vector<int> prev(4,0) ;
    
    prev[0] = max(grid[0][1], grid[0][2]) ;
    prev[1] = max(grid[0][0], grid[0][2]) ;
    prev[2] = max(grid[0][0], grid[0][1]) ;
    prev[3] = max(grid[0][0], max(grid[0][1], grid[0][2])) ;
    
    for(int day = 1 ; day < n ; day++) {
        vector<int> curr(4,0) ;
        for(int last = 0 ; last < 4 ; last++) {
            
            int maxi = -1e9 ;
            for(int task = 0 ; task < 3 ; task++) {
                if(task != last) {
                    int activity = grid[day][task] + prev[task] ;
                    curr[last] = max(curr[last],activity) ;
                }
            }
        }
        prev = curr ;
    }
    
    cout << prev[3] ;
    
}
